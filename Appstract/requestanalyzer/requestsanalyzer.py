""" 
A command-line tool that scrapes the Appstract request email inbox for all requests.
The tool performs an analysis on all apps requested, and then outputs the ones with 
the highest number of requests. Adapted from Gmail's API sample code.
Note that this tool requires a user to login to the email inbox they'd like to scrape;
as such, it can be used by anybody, but the functionality won't work unless your inbox
happens to be filled with request emails generated by CandyBar Dashboard.
"""

from __future__ import print_function
import pickle
import os.path
import base64
import re
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

"""
TODO: (ranked: short-term -> long-term):
-create dictionary to track frequency of icon names
-get more than just the first icon requested from an email
-make extracting the payload from the message more reliable (aka remove try/excepts)
-create tuples to store requested icons like: ("Icon_Name", "com.icon.android/activities.Home")
    -requires writing another search function to extract the icon's implementation code
"""

# If modifying these scopes, delete the file token.pickle.
SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']

def getRequestName(decoded_payload):
    #find the first requested icon name, using "CandyBar Version" to detect if it's a free request email
    if "CandyBar Version" in decoded_payload and "Order Id" not in decoded_payload:
        match = re.search("CandyBar Version[ \n]: \d.\d.\d-b4(\\\\n){1,3}", decoded_payload)

        if match is not None:
            #determines the location of the first letter of an icon
            start = match.span()[1]

            tempstr = ""
            count = 0
            currentchar = ""

            #iterate from first letter to terminating "\n" or 20 characters, whichever comes first
            while not(count > 20):
                currentchar = str(decoded_payload[start + count])

                #check for terminating "\n"
                if currentchar == "\\":
                    break

                tempstr += currentchar
                count += 1

            return(tempstr)

        if match is None:
            return("No match found")

    else:
        return("Upon")

def main():
    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', SCOPES)
            creds = flow.run_local_server()
        # Save the credentials for the next run
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)

    service = build('gmail', 'v1', credentials=creds)

    # call the Gmail API
    response = service.users().messages().list(userId="me").execute()

    # get every email in the inbox and store it in messages
    messages = []
    if "messages" in response:
        messages.extend(response["messages"])
    
    while "nextPageToken" in response:
        page_token = response['nextPageToken']
        response = service.users().messages().list(userId="me", pageToken=page_token).execute()
        messages.extend(response['messages'])

    #now that we have all the messages, process them
    for message in messages:
        message_id = message["id"]
        
        #get an individual message by its id
        individual_message = service.users().messages().get(userId='me', id=str(message_id), format="full").execute()

        #check if this is a free request email
        if "CandyBar Version" in str(individual_message["snippet"]) and "Order Id" not in str(individual_message["snippet"]):
            #extract the body from the message, which is base64 encoded
            try:
                payload = individual_message["payload"]["parts"][0]["parts"][0]["body"]["data"]
            except:
                payload = individual_message["payload"]["parts"][0]["body"]["data"]

        #decode the payload, giving the plain text body of the email
        decoded_payload = str(base64.b64decode(payload, '-_')).replace("\\r","")

        #extract the name of the first request
        print(getRequestName(decoded_payload))

if __name__ == '__main__':
    main()